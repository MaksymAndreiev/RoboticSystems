#define F_CPU 16000000UL

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

void ADC_init() {
    ADCSRA |= (1 << ADEN)                                    //Вмикаємо АЦП
              | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0)                //Дільник 128
              | (1 << ADATE)                                        //Вмикаємо режим автоматичного запуску АЦП
              | (1
            << ADIE);                                        //Дозволяємо переривання по завершенню перетворення АЦП
    ADMUX |= (1 << REFS0)                                    //Вмикаємо внутрішній ДОН
             | (1 << MUX1);                                        //Вхід ADC2(A2);
    ADCSRB = 0;                                            //Безперервне перетворювання
    ADCSRA |= (1 << ADSC);                                //Розпочинаємо перетворювання
}

void UART_init() {
    UBRR0H = 0;
    UBRR0L = 103;                                         //Швидкість передачі даних 9600 Бод
    UCSR0B |= (1 << TXEN0);                                 //Дозволяємо передачу
}

void UART_transmit(uint8_t c) {                          //Функція для передачі символу
    while (!(UCSR0A & (1 << UDRE0)));                        //Чекаємо, доки буфер не звільниться
    UDR0 = c;                                             //Записуємо символ в буфер
}

void UART_transmit_str(char *str) {                      //Функція для передачі рядку
    uint8_t c;
    while ((c = *str++) != 0) {                             //Доки рядок не закінчився
        UART_transmit(c);                                   //Передаємо його посимвольно
    }
}

void UART_transmit_digit(uint8_t d) {                    //Функція для передачі цифри
    while (!(UCSR0A & (1 << UDRE0)));                        //Чекаємо, доки буфер не звільниться
    UDR0 = d + 0x30;                                      //Записуємо цифру в буфер
}

void UART_transmit_uint(uint16_t D) {                    //Функція для передачі числа
    uint8_t mas[6], i = 0;                                //Масив для зберігання числа поелементно
    do {
        mas[i++] = D % 10;                                  //Записуємо останню цифру числа
        D /= 10;                                            //Переходимо до наступного розряду
    } while (D > 0);                                      //Доки число не 0
    for (; i > 0; i--) {                                     //Перебираємо масив
        UART_transmit_digit(
                mas[i - 1]);                    //Записуємо масив в зворотньому напрямку, формуємо число в моніторі
    }
}

int main(void) {
    DDRB |= (1 << DDB1);                                            //Налаштовуємо пін PB1=D9=OC1A на ВИХІД
    DDRB |= (1 << DDB2);                                            //Налаштовуємо пін PB2=D10=OC1B на ВИХІД
    TCCR1A |= (1 << WGM10) | (1 << WGM11);                            //режим Phase Correct #3 (TOP=1023)
    TCCR1B |= (1 << CS11) | (1 << CS10);                            //Дільник 64
    TCCR1A |= (1 << COM1A1) | (1 << COM1B1);                        //Неінвертований ШИМ
    ADC_init();
    UART_init();
    sei();
    while (1) {
        UART_transmit_str("OCR1A = ");                      //Передаємо рядок
        UART_transmit_uint(OCR1A);                          //Передаємо число
        UART_transmit_str("   OCR1B = ");                    //Передаємо рядок
        UART_transmit_uint(OCR1B);                          //Передаємо число
        UART_transmit(0x0D);                                //Переходимо на наступний рядок
        _delay_ms(1000);
    }
}

ISR(ADC_vect){                                          //Обробник переривання по завершенню перетворення АЦП
        if (ADC < 512){                                       //Якщо значення менше половини
            OCR1A = ADC *
                    2;                                    //Записуємо його в регістр OCR1A, збільшуємо вдвічі для налаштування яркості
            OCR1B = 0;                                          //0 в регістр OCR1B
        } else {                                              //Інакше
            OCR1B = (ADC - 512) *
                    2;                            //Записуємо в регістр OCR1A значення, від якого віднімаємо половину,
            //збільшуємо результат вдвічі для налаштування яркості
            OCR1A = 1023;                                       //Максимальне значення в регістр OCR1A, максимальна яскравість світлодіоду
        }
}